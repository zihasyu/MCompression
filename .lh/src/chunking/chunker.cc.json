{
    "sourceFile": "src/chunking/chunker.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1733387279754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733387406252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,9 +121,9 @@\n             switch (chunkType)\n             {\n             case FIXED_SIZE:\n             {\n-                cp = avgChunkSize; // 8KB\n+                cp = min(avgChunkSize, len - localOffset); // 8KB\n                 break;\n             }\n             case FASTCDC:\n             {\n"
                }
            ],
            "date": 1733387279754,
            "name": "Commit-0",
            "content": "#include \"../../include/chunker.h\"\n\nChunker::Chunker(int chunkType_)\n{\n\n    FixedChunkSize = 8192;\n    // specifiy chunk type\n    chunkType = chunkType_;\n    // init chunker\n    ChunkerInit();\n    // in different chunking method, the chunkBuffer is different\n}\nChunker::~Chunker()\n{\n    free(readFileBuffer);\n    free(chunkBuffer);\n\n    if (chunkType == TAR_MultiHeader)\n        free(headerBuffer);\n}\n\nvoid Chunker::LoadChunkFile(string path)\n{\n    if (inputFile.is_open())\n    {\n        inputFile.close();\n    }\n\n    inputFile.open(path, ios_base::in | ios::binary);\n    if (!inputFile.is_open())\n    {\n        tool::Logging(myName_.c_str(), \"open file: %s error.\\n\",\n                      path.c_str());\n        exit(EXIT_FAILURE);\n    }\n    return;\n}\n\nvoid Chunker::ChunkerInit()\n{\n    switch (chunkType)\n    {\n    case FIXED_SIZE:\n    {\n        // fixed size chunking]\n        readFileBuffer = (uint8_t *)malloc(READ_FILE_SIZE);\n        chunkBuffer = (uint8_t *)malloc(FixedChunkSize);\n        break;\n    }\n    case MTAR:\n\n    case FASTCDC: // FastCDC chunking\n    {\n        readFileBuffer = (uint8_t *)malloc(READ_FILE_SIZE);\n        chunkBuffer = (uint8_t *)malloc(MAX_CHUNK_SIZE);\n        normalSize = CalNormalSize(minChunkSize, avgChunkSize, maxChunkSize);\n        bits = (uint32_t)round(log2(static_cast<double>(avgChunkSize)));\n        maskS = GenerateFastCDCMask(bits + 1);\n        maskL = GenerateFastCDCMask(bits - 1);\n        break;\n    }\n    case GEARCDC: // Gear chunking\n    {\n        readFileBuffer = (uint8_t *)malloc(READ_FILE_SIZE);\n        chunkBuffer = (uint8_t *)malloc(MAX_CHUNK_SIZE);\n        break;\n    }\n    case TAR:\n    {\n        readFileBuffer = (uint8_t *)malloc(READ_FILE_SIZE);\n        chunkBuffer = (uint8_t *)malloc(CONTAINER_MAX_SIZE); // 4MB\n        normalSize = CalNormalSize(minChunkSize, avgChunkSize, maxChunkSize);\n        bits = (uint32_t)round(log2(static_cast<double>(avgChunkSize)));\n        maskS = GenerateFastCDCMask(bits + 1);\n        maskL = GenerateFastCDCMask(bits - 1);\n        break;\n    }\n    case TAR_MultiHeader:\n    {\n        readFileBuffer = (uint8_t *)malloc(READ_FILE_SIZE);\n        headerBuffer = (uint8_t *)malloc(512 * 32);\n        chunkBuffer = (uint8_t *)malloc(CONTAINER_MAX_SIZE); // 4MB\n        // dataBuffer = (uint8_t *)malloc(CONTAINER_MAX_SIZE * 16); // 64MB\n        normalSize = CalNormalSize(minChunkSize, avgChunkSize, maxChunkSize);\n        bits = (uint32_t)round(log2(static_cast<double>(avgChunkSize)));\n        maskS = GenerateFastCDCMask(bits + 1);\n        maskL = GenerateFastCDCMask(bits - 1);\n        break;\n    }\n\n    default:\n        tool::Logging(myName_.c_str(), \"chunk type error.\\n\");\n        exit(EXIT_FAILURE);\n        break;\n    }\n    return;\n}\n\nvoid Chunker::Chunking()\n{\n    bool end = false;\n    uint64_t totalOffset = 0;\n\n    while (!end)\n    {\n        memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n        inputFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n        end = inputFile.eof();\n        size_t len = inputFile.gcount();\n        if (len == 0)\n        {\n            break;\n        }\n        localOffset = 0;\n        while (((len - localOffset) >= CONTAINER_MAX_SIZE * 16) || (end && (localOffset < len)))\n        {\n            // cout << \" len is \" << len << \" localOffset is \" << localOffset << endl;\n            Chunk_t chunk;\n            // compute cutPoint\n            uint64_t cp = 0;\n            switch (chunkType)\n            {\n            case FIXED_SIZE:\n            {\n                cp = avgChunkSize; // 8KB\n                break;\n            }\n            case FASTCDC:\n            {\n                cp = CutPointFastCDC(readFileBuffer + localOffset, len - localOffset);\n                break;\n            }\n            case GEARCDC:\n            {\n                cp = CutPointGear(readFileBuffer + localOffset, len - localOffset);\n                break;\n            }\n            case TAR:\n            {\n                cp = CutPointTarFast(readFileBuffer + localOffset, len - localOffset);\n                break;\n            }\n            case TAR_MultiHeader:\n            {\n                SetTime(startChunk);\n                size_t cpOffset = CutPointTarHeader(readFileBuffer + localOffset, len - localOffset);\n                localOffset += cpOffset;\n                SetTime(endChunk);\n                ChunkTime += (endChunk - startChunk);\n                continue;\n            }\n            default:\n                cout << \"chunkType error\" << endl;\n                break;\n            }\n            chunk.chunkPtr = (uint8_t *)malloc(cp);\n            cout << \"cp is \" << cp << endl;\n            memcpy(chunk.chunkPtr, readFileBuffer + localOffset, cp);\n            chunk.chunkSize = cp;\n            // chunk.chunkID = chunkID++;太早了\n            if (cp == 0)\n            {\n                // cout << \"cp is 0\" << endl; // debug\n                continue;\n            }\n            localOffset += cp;\n            if (!outputMQ_->Push(chunk))\n            {\n                tool::Logging(myName_.c_str(), \"insert chunk to output MQ error.\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n        totalOffset += localOffset;\n        inputFile.seekg(totalOffset, ios_base::beg);\n    }\n    // cout << \"chunking done.\" << endl;\n\n    outputMQ_->done_ = true;\n    tool::Logging(myName_.c_str(), \"chunking done.\\n\");\n    return;\n}\n\nuint64_t Chunker::CutPointFastCDC(const uint8_t *src, const uint64_t len)\n{\n    uint64_t n;\n    uint32_t fp = 0;\n    uint64_t i;\n    i = min(len, static_cast<uint64_t>(minChunkSize));\n    n = min(normalSize, len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskS))\n        {\n            return (i + 1);\n        }\n    }\n\n    n = min(static_cast<uint64_t>(maxChunkSize), len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskL))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\nuint32_t Chunker::CutPointGear(const uint8_t *src, const uint64_t len)\n{\n    uint32_t fp = 0;\n    uint64_t i = 0;\n    for (; i < len; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & MASK_GEAR))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\nuint64_t Chunker::CutPointTarFast(const uint8_t *src, const uint64_t len)\n{\n    switch (Next_Chunk_Type)\n    {\n    case FILE_HEADER:\n    {\n        uint8_t data[12];\n        std::memcpy(data, src + 124, 12);\n\n        Next_Chunk_Size = 0;\n        for (int i = 0; i < 11; i++)\n        {\n            Next_Chunk_Size = Next_Chunk_Size * 8 + data[i] - 48;\n        }\n        if (*(src + 156) == REGTYPE)\n        {\n            if (Next_Chunk_Size <= CONTAINER_MAX_SIZE)\n                Next_Chunk_Type = FILE_CHUNK;\n            else\n            {\n                Next_Chunk_Type = BIG_CHUNK;\n                Big_Chunk_Size = (Next_Chunk_Size + 511) / 512 * 512;\n                Big_Chunk_Offset = 0;\n                // Big_Chunk_Allowance = Next_Chunk_Size / CONTAINER_MAX_SIZE;\n                // Big_Chunk_Last_Size = Next_Chunk_Size % CONTAINER_MAX_SIZE;\n                // if (Big_Chunk_Last_Size == 0)\n                // {\n                //     Big_Chunk_Allowance--;\n                //     Big_Chunk_Last_Size = CONTAINER_MAX_SIZE;\n                // }\n                // cout << \"REGTYPE BigChunkSize is \" << Big_Chunk_Size << endl;\n            }\n        }\n        if (*(src + 156) == AREGTYPE)\n        {\n            Next_Chunk_Size = 0;\n            for (int i = 0; i < 11; i++)\n            {\n                Next_Chunk_Size = Next_Chunk_Size * 8 + data[i];\n            }\n            // cout << \"AREGTYPE ChunkSize is \" << Next_Chunk_Size << endl;\n            Next_Chunk_Size = 0;\n            if (Next_Chunk_Size <= CONTAINER_MAX_SIZE)\n                Next_Chunk_Type = FILE_CHUNK;\n            else\n            {\n                Next_Chunk_Type = BIG_CHUNK;\n                Next_Chunk_Size = 0;\n                for (int i = 0; i < 11; i++)\n                {\n                    Next_Chunk_Size = Next_Chunk_Size * 8 + data[i] - 48;\n                    cout << data[i];\n                }\n                Big_Chunk_Size = (Next_Chunk_Size + 511) / 512 * 512;\n                Big_Chunk_Offset = 0;\n                // cout << \"AREGTYPE BigChunkSize is \" << Big_Chunk_Size << endl;\n            }\n        }\n        if (*(src + 156) == 'x' || *(src + 156) == GNUTYPE_LONGNAME)\n            Next_Chunk_Type = FILE_CHUNK;\n        /*use to debug*/\n        // cout<<\"Next_Chunk_Flag: \" <<int(*(src + 156));\n        // cout<<\"Next_Chunk_Type: \" <<Next_Chunk_Type;\n        // cout<<\"Next_Chunk_Size: \"<<Next_Chunk_Size<<endl;\n        // if(int(*(src + 156)) == 32||int(*(src + 156)) == 0){\n        //     for(int i=0;i<512;i++)\n        //     cout<<src[i]<<\" \";\n        //     cout<<endl;\n        // }\n\n        if (len >= 512)\n            return 512;\n        else\n        {\n            // printf(\"emmmm\");\n            return len;\n        }\n        break;\n    }\n    case FILE_CHUNK:\n    {\n        uint64_t roundedUp = (Next_Chunk_Size + 511) / 512 * 512;\n        Next_Chunk_Type = FILE_HEADER;\n        Next_Chunk_Size = 512;\n        if (roundedUp < len)\n            return roundedUp;\n        else\n            return len;\n        break;\n    }\n    case BIG_CHUNK:\n    {\n        if (Big_Chunk_Size - Big_Chunk_Offset > maxChunkSize)\n        {\n            // Big_Chunk_Allowance--;\n            // cout << \" BigChunkSize is \" << Big_Chunk_Size << \" BigChunkOffset is\" << Big_Chunk_Offset << endl;\n            uint64_t cp = CutPointFastCDC(src,\n                                          Big_Chunk_Size - Big_Chunk_Offset);\n            Big_Chunk_Offset += cp;\n            // cout << \"offset is \" << Big_Chunk_Offset << \" cp is \" << cp << endl;\n            return cp;\n            // return CONTAINER_MAX_SIZE;\n        }\n        else\n        {\n            Next_Chunk_Type = FILE_HEADER;\n            return Big_Chunk_Size - Big_Chunk_Offset;\n        }\n        break;\n    }\n    }\n};\nuint32_t Chunker::GenerateFastCDCMask(uint32_t bits)\n{\n    uint32_t tmp;\n    tmp = (1 << CompareLimit(bits, 1, 31)) - 1;\n    return tmp;\n}\ninline uint32_t Chunker::CompareLimit(uint32_t input, uint32_t lower, uint32_t upper)\n{\n    if (input <= lower)\n    {\n        return lower;\n    }\n    else if (input >= upper)\n    {\n        return upper;\n    }\n    else\n    {\n        return input;\n    }\n}\nuint32_t Chunker::CalNormalSize(const uint32_t min, const uint32_t av, const uint32_t max)\n{\n    uint32_t off = min + DivCeil(min, 2);\n    if (off > av)\n    {\n        off = av;\n    }\n    uint32_t diff = av - off;\n    if (diff > max)\n    {\n        return max;\n    }\n    return diff;\n}\ninline uint32_t Chunker::DivCeil(uint32_t a, uint32_t b)\n{\n    uint32_t tmp = a / b;\n    if (a % b == 0)\n    {\n        return tmp;\n    }\n    else\n    {\n        return (tmp + 1);\n    }\n}\n\nuint64_t Chunker::CutPointTarHeader(const uint8_t *src, const uint64_t len)\n// 调用CutPointTarFast，因为有NextChunkType的全局变量，所以断在哪里都没关系。但是为了减少recipe压力（一对segment可恢复），满足结尾时下一个type还是header即可。\n{\n    uint64_t blockTypeMask;\n    uint64_t cpSum = 0;\n    uint64_t loopTime = 1;\n    if (Next_Chunk_Type == FILE_HEADER)\n    {\n        while ((HeaderCp < MultiHeaderSize || (localType == FILE_HEADER && Next_Chunk_Type == FILE_CHUNK)) && Next_Chunk_Type != BIG_CHUNK)\n        // 当前是H下一个块也是H时，认为当前的H不指导切块，例如是目录，所以可以断。\n        // 当前是D下一个块也是D时，应该是大块，也是可以断的。\n        // 当前是D下一个块是H时，是正常的HD组合，也可以断。\n        // 总结一下就是，当前为H，下一块为D时不可以断\n        // 附加一条，下一个块是大块内容的时候也不在当前seg里切了\n        {\n            localType = Next_Chunk_Type;\n            uint32_t cp = CutPointTarFast(src + cpSum, len - cpSum);\n\n            if (localType == FILE_HEADER)\n            {\n                memcpy(headerBuffer + HeaderCp, src + cpSum, cp);\n                HeaderCp += cp;\n                // blockTypeMask = blockTypeMask;\n            }\n            else\n            {\n                if (cp == 0)\n                {\n                    // cout << \"data cp is 0\" << endl; // debug\n                    continue;\n                }\n                // data chunking\n                Chunk_t chunk;\n                chunk.chunkPtr = (uint8_t *)malloc(cp);\n                memcpy(chunk.chunkPtr, src + cpSum, cp);\n                chunk.chunkSize = cp;\n                // input MQ\n                if (!outputMQ_->Push(chunk))\n                {\n                    tool::Logging(myName_.c_str(), \"insert chunk to output MQ error.\\n\");\n                    exit(EXIT_FAILURE);\n                }\n                // mask\n                blockTypeMask = blockTypeMask + loopTime;\n                if (loopTime > UINT32_MAX)\n                {\n                    cout << \"loopTime overflow is\" << loopTime << endl;\n                }\n            }\n            // local offset\n            cpSum += cp;\n            if (cpSum == len)\n            {\n                Next_Chunk_Type = FILE_HEADER;\n                break; // 同时，这个backup结束了，可能要设计个flag\n            }\n            loopTime *= 2;\n        }\n        // input recipe MQ\n        // if (!MaskoutputMQ_->Push(blockTypeMask))\n        // {\n        //     tool::Logging(myName_.c_str(), \"insert chunk to output MQ error.\\n\");\n        //     exit(EXIT_FAILURE);\n        // }\n        // multi header\n        Chunk_t chunk;\n        chunk.chunkPtr = (uint8_t *)malloc(HeaderCp);\n        memcpy(chunk.chunkPtr, headerBuffer, HeaderCp);\n        chunk.chunkSize = HeaderCp;\n        chunk.HeaderFlag = true;\n        // reset\n        HeaderCp = 0;\n        // input chunk MQ\n        if (!outputMQ_->Push(chunk))\n        {\n            tool::Logging(myName_.c_str(), \"insert chunk to output MQ error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    else\n    {\n        // cout << \" Next_Chunk_Type is \" << Next_Chunk_Type << endl;\n        //  不以header为开头只可能是bigchunk，这里想要的处理的bigchunk开头时\n        while (Next_Chunk_Type != FILE_HEADER && cpSum < CONTAINER_MAX_SIZE - MAX_CHUNK_SIZE)\n        // 当前是H下一个块也是H时，认为当前的H不指导切块，例如是目录，所以可以断。\n        // 当前是D下一个块也是D时，应该是大块，也是可以断的。\n        // 当前是D下一个块是H时，是正常的HD组合，也可以断。\n        // 总结一下就是，当前为H，下一块为D时不可以断\n        {\n            localType = Next_Chunk_Type;\n            uint32_t cp = CutPointTarFast(src + cpSum, len - cpSum);\n            // cout << \"big cdc size is \" << cp << endl;\n            if (localType == FILE_HEADER)\n            {\n                std::cout << \"cut_bug\";\n                // memcpy(headerBuffer + HeaderCp, src + cpSum, cp);\n                // HeaderCp += cp;\n                // blockTypeMask = blockTypeMask;\n            }\n            else\n            {\n                Chunk_t chunk;\n                chunk.chunkPtr = (uint8_t *)malloc(cp);\n                memcpy(chunk.chunkPtr, src + cpSum, cp);\n                chunk.chunkSize = cp;\n                if (!outputMQ_->Push(chunk))\n                {\n                    tool::Logging(myName_.c_str(), \"insert chunk to output MQ error.\\n\");\n                    exit(EXIT_FAILURE);\n                }\n            }\n            cpSum += cp;\n            if (cpSum == len)\n            {\n                break; // 同时，这个backup结束了，可能要设计个flag\n            }\n        }\n    }\n\n    // cout << \"HeaderCp is \" << HeaderCp << endl;\n    // cout << \"DataCp is \" << DataCp << endl;\n    return cpSum;\n}\n\nvoid Chunker::MTar(vector<string> &readfileList, uint32_t backupNum)\n{\n\n    for (int i = 0; i < backupNum; i++)\n    {\n        string name;\n        size_t pos = readfileList[i].find_last_of('/');\n        if (pos != std::string::npos)\n        {\n            name = readfileList[i].substr(pos + 1);\n        }\n        else\n        {\n            name = readfileList[i];\n        }\n        string writePath = \"./mTarFile/\" + name + \".m\";\n        cout << \"write path is \" << writePath << endl;\n        // stream set\n        ifstream inFile(readfileList[i]);\n        ofstream outFile(writePath);\n\n        // data chunk rewrite\n        bool end = false;\n        uint64_t totalOffset = 0;\n        while (!end)\n        {\n            memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n            inFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n            end = inFile.eof();\n            size_t len = inFile.gcount();\n            if (len == 0)\n            {\n                break;\n            }\n            localOffset = 0;\n            while (((len - localOffset) >= CONTAINER_MAX_SIZE) || (end && (localOffset < len)))\n            {\n                // cout << \" len is \" << len << \" localOffset is \" << localOffset << endl;\n                // compute cutPoint\n                localType = Next_Chunk_Type;\n                uint32_t cp = CutPointTarFast(readFileBuffer + localOffset, len - localOffset);\n                if (cp == 0)\n                {\n                    continue;\n                }\n                if (localType != FILE_HEADER)\n                {\n                    outFile.write((char *)readFileBuffer + localOffset, cp);\n                }\n\n                localOffset += cp;\n            }\n            totalOffset += localOffset;\n            inFile.seekg(totalOffset, ios_base::beg);\n        }\n        // reset\n        localType = FILE_HEADER;\n        Next_Chunk_Type = FILE_HEADER;\n        ifstream inHeaderFile(readfileList[i]);\n        // header chunk rewrite\n        inHeaderFile.seekg(0, ios_base::beg);\n        end = false;\n        totalOffset = 0;\n        while (!end)\n        {\n            memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n            inHeaderFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n            end = inHeaderFile.eof();\n            size_t len = inHeaderFile.gcount();\n            if (len == 0)\n            {\n                break;\n            }\n            localOffset = 0;\n            while (((len - localOffset) >= CONTAINER_MAX_SIZE) || (end && (localOffset < len)))\n            {\n                // cout << \" len is \" << len << \" localOffset is \" << localOffset << endl;\n                // compute cutPoint\n                localType = Next_Chunk_Type;\n                uint32_t cp = CutPointTarFast(readFileBuffer + localOffset, len - localOffset);\n                if (cp == 0)\n                {\n                    continue;\n                }\n                if (localType == FILE_HEADER)\n                {\n                    outFile.write((char *)readFileBuffer + localOffset, cp);\n                }\n\n                localOffset += cp;\n            }\n            totalOffset += localOffset;\n            inHeaderFile.seekg(totalOffset, ios_base::beg);\n        }\n\n        // reset\n        localType = FILE_HEADER;\n        Next_Chunk_Type = FILE_HEADER;\n        inFile.close();\n        inHeaderFile.close();\n        outFile.close();\n        // mtar overwrite the readfileList\n        readfileList[i] = writePath;\n    }\n    // reset\n    chunkType = FASTCDC;\n    localType = FILE_HEADER;\n    Next_Chunk_Type = FILE_HEADER;\n    return;\n}"
        }
    ]
}
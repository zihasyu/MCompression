{
    "sourceFile": "src/app/main.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 18,
            "patches": [
                {
                    "date": 1733384965800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733385501645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,21 +149,21 @@\n         else\n             absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n     }\n \n-    auto endsum = std::chrono::high_resolution_clock::now();\n-    auto sumTime = (endsum - startsum);\n-    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n-    std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n-    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n-    tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n-    tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n-    tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n-    tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n-    if (compressionMethod != 5)\n-        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n-    else\n-        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n+    // auto endsum = std::chrono::high_resolution_clock::now();\n+    // auto sumTime = (endsum - startsum);\n+    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n+    // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n+    // tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n+    // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n+    // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n+    // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n+    // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n+    // if (compressionMethod != 5)\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n+    // else\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n \n     //  restore backup if you need, but it's not necessary\n     // if (chunkingType != TAR_MultiHeader)\n     //     for (auto i = 0; i < backupNum; i++)\n@@ -177,9 +177,9 @@\n     //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n     //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n     //     }\n \n-    string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n+    // string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n     // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n     delete absMethodObj->dataWrite_;\n     delete chunkerObj;\n     delete absMethodObj;\n"
                },
                {
                    "date": 1733386974371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,14 +143,11 @@\n             delete it;\n         }\n         auto endTmp = std::chrono::high_resolution_clock::now();\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n-        if (compressionMethod != 5)\n-            absMethodObj->Version_log(TimeTmp);\n-        else\n-            absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n     }\n-\n+    absMethodObj->Migratory();\n+    absMethodObj->MLC();\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733388154034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,8 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n+    absMethodObj->OriLC(dirName);\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733388283114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n-    absMethodObj->OriLC(dirName);\n+    absMethodObj->OriLC(readfileList[0]);\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733452470212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n-    absMethodObj->OriLC(readfileList[0]);\n+    absMethodObj->OriLC(\"ori\");\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733452476331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,8 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n+    absMethodObj->OriGenerate(readfileList);\n     absMethodObj->OriLC(\"ori\");\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n"
                },
                {
                    "date": 1733452708952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n-    absMethodObj->OriGenerate(readfileList);\n+    absMethodObj->OriGenerate(readfileList, backupNum);\n     absMethodObj->OriLC(\"ori\");\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n"
                },
                {
                    "date": 1733453166612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,21 +146,22 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n+\n+    auto endsum = std::chrono::high_resolution_clock::now();\n+    auto sumTime = (endsum - startsum);\n+    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     absMethodObj->OriGenerate(readfileList, backupNum);\n     absMethodObj->OriLC(\"ori\");\n-    // auto endsum = std::chrono::high_resolution_clock::now();\n-    // auto sumTime = (endsum - startsum);\n-    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n-    // tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n+    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n     // if (compressionMethod != 5)\n-    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n+    absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n     // else\n     //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n \n     //  restore backup if you need, but it's not necessary\n"
                },
                {
                    "date": 1733453945973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,22 +146,21 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n-\n-    auto endsum = std::chrono::high_resolution_clock::now();\n-    auto sumTime = (endsum - startsum);\n-    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     absMethodObj->OriGenerate(readfileList, backupNum);\n     absMethodObj->OriLC(\"ori\");\n+    // auto endsum = std::chrono::high_resolution_clock::now();\n+    // auto sumTime = (endsum - startsum);\n+    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n     // if (compressionMethod != 5)\n-    absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n     // else\n     //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n \n     //  restore backup if you need, but it's not necessary\n"
                },
                {
                    "date": 1733454140143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,9 +152,9 @@\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n-    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n+    std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                },
                {
                    "date": 1733454181735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,8 +153,9 @@\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n+    std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                },
                {
                    "date": 1733454209350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,8 +154,9 @@\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n+    std::cout << \"Migratory lossless compression size : \" << absMethodObj->oriMLCSize << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                },
                {
                    "date": 1733454215031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,9 +154,9 @@\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n-    std::cout << \"Migratory lossless compression size : \" << absMethodObj->oriMLCSize << std::endl;\n+    std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                },
                {
                    "date": 1733454311097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,16 +155,17 @@\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n     std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n+    std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n     // if (compressionMethod != 5)\n     //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n     // else\n-    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n+    // absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n \n     //  restore backup if you need, but it's not necessary\n     // if (chunkingType != TAR_MultiHeader)\n     //     for (auto i = 0; i < backupNum; i++)\n"
                },
                {
                    "date": 1733454316897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,12 +152,13 @@\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n+    std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n     std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n-    std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n+\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                },
                {
                    "date": 1733465622020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,191 @@\n+#include <iostream>\n+#include <string>\n+#include <csignal>\n+#include <sstream>\n+#include <chrono>\n+\n+#include \"../../include/allmethod.h\"\n+\n+using namespace std;\n+\n+void signalHandler(int signum)\n+{\n+    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n+    exit(signum);\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    signal(SIGINT, signalHandler);\n+\n+    uint32_t chunkingType;\n+    uint32_t compressionMethod;\n+    uint32_t backupNum;\n+    double ratio = 8;\n+    string dirName;\n+    string myName = \"MC\";\n+\n+    vector<string> readfileList;\n+\n+    const char optString[] = \"i:m:c:n:r:\";\n+    if (argc != sizeof(optString) && argc != sizeof(optString) - 2)\n+    {\n+        cout << \"argc is \" << argc << endl;\n+        cout << \"Usage: \" << argv[0] << \" -i <input file> -m <chunking method> -c <compression method> -n <process number> -r <Bisearch fault ratio>\" << endl;\n+        return 0;\n+    }\n+\n+    // Grab command-line instructions\n+    int option = 0;\n+    while ((option = getopt(argc, argv, optString)) != -1)\n+    {\n+        switch (option)\n+        {\n+        case 'i':\n+            dirName.assign(optarg);\n+            break;\n+        case 'c':\n+            chunkingType = atoi(optarg);\n+            break;\n+        case 'm':\n+            compressionMethod = atoi(optarg);\n+            break;\n+        case 'n':\n+            backupNum = atoi(optarg);\n+            break;\n+        case 'r':\n+            ratio = atoi(optarg);\n+            break;\n+        default:\n+            break;\n+        }\n+    }\n+\n+    AbsMethod *absMethodObj;\n+    Chunker *chunkerObj = new Chunker(chunkingType);\n+\n+    MessageQueue<Chunk_t> *chunkerMQ = new MessageQueue<Chunk_t>(CHUNK_QUEUE_SIZE);\n+\n+    switch (compressionMethod)\n+    {\n+    case DEDUP:\n+    {\n+        absMethodObj = new Dedup();\n+        break;\n+    }\n+    case NTRANSFORM:\n+    {\n+        absMethodObj = new NTransForm();\n+        break;\n+    }\n+    case FINESSE:\n+    {\n+        absMethodObj = new Finesse();\n+        break;\n+    }\n+    case ODESS:\n+    {\n+        absMethodObj = new Odess();\n+        break;\n+    }\n+    case PALANTIR:\n+    {\n+        absMethodObj = new Palantir();\n+        break;\n+    }\n+    case LOCALITY:\n+    {\n+        absMethodObj = new LocalDedup();\n+        break;\n+    }\n+    default:\n+        break;\n+    }\n+\n+    tool::traverse_dir(dirName, readfileList, nofilter);\n+    sort(readfileList.begin(), readfileList.end(), AbsMethod::compareNat);\n+\n+    boost::thread *thTmp[2] = {nullptr};\n+    boost::thread::attributes attrs;\n+    attrs.set_stack_size(THREAD_STACK_SIZE);\n+    chunkerObj->SetOutputMQ(chunkerMQ);\n+    absMethodObj->SetInputMQ(chunkerMQ);\n+    absMethodObj->dataWrite_ = new dataWrite();\n+\n+    // new design\n+    // if (chunkingType == TAR_MultiHeader)\n+    // {\n+    //     MessageQueue<uint64_t> *MaskMQ = new MessageQueue<uint64_t>(CHUNK_QUEUE_SIZE);\n+    //     chunkerObj->SetOutputMaskMQ(MaskMQ);\n+    //     absMethodObj->SetInputMaskMQ(MaskMQ);\n+    // }\n+    auto startsum = std::chrono::high_resolution_clock::now();\n+    if (chunkingType == MTAR)\n+    {\n+        chunkerObj->MTar(readfileList, backupNum);\n+    }\n+    for (auto i = 0; i < backupNum; i++)\n+    {\n+        auto startTmp = std::chrono::high_resolution_clock::now();\n+        // set backup name\n+        chunkerObj->LoadChunkFile(readfileList[i]);\n+        absMethodObj->SetFilename(readfileList[i]);\n+        absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n+        // thread running\n+        thTmp[0] = new boost::thread(attrs, boost::bind(&Chunker::Chunking, chunkerObj));\n+        thTmp[1] = new boost::thread(attrs, boost::bind(&AbsMethod::ProcessTrace, absMethodObj));\n+        for (auto it : thTmp)\n+        {\n+            it->join();\n+        }\n+        for (auto it : thTmp)\n+        {\n+            delete it;\n+        }\n+        auto endTmp = std::chrono::high_resolution_clock::now();\n+        auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n+    }\n+    absMethodObj->Migratory();\n+    absMethodObj->MLC();\n+    absMethodObj->OriGenerate(readfileList, backupNum);\n+    absMethodObj->OriLC(\"ori\");\n+    // auto endsum = std::chrono::high_resolution_clock::now();\n+    // auto sumTime = (endsum - startsum);\n+    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n+    // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n+    std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n+    std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n+    std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n+    std::cout << \"Ori lossless compression ratio: \" << (double)absMethodObj->(double)logicalchunkSize / absMethodObj->oriLCSize << std::endl;\n+    std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n+    std::cout << \"Migration lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / absMethodObj->MLCSize << std::endl;\n+    // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n+    // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n+    // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n+    // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n+    // if (compressionMethod != 5)\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n+    // else\n+    // absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n+\n+    //  restore backup if you need, but it's not necessary\n+    // if (chunkingType != TAR_MultiHeader)\n+    //     for (auto i = 0; i < backupNum; i++)\n+    //     {\n+    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n+    //         absMethodObj->dataWrite_->restoreFile(readfileList[i]);\n+    //     }\n+    // else\n+    //     for (auto i = 0; i < backupNum; i++)\n+    //     {\n+    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n+    //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n+    //     }\n+\n+    // string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n+    // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n+    delete absMethodObj->dataWrite_;\n+    delete chunkerObj;\n+    delete absMethodObj;\n+    return 0;\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733465660535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,11 +155,12 @@\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n-    std::cout << \"Ori lossless compression ratio: \" << (double)absMethodObj->(double)logicalchunkSize / absMethodObj->oriLCSize << std::endl;\n+    std::cout << \"Ori lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / (double)absMethodObj->oriLCSize << std::endl;\n     std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n-    std::cout << \"Migration lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / absMethodObj->MLCSize << std::endl;\n+    std::cout << \"Migration lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / (double)absMethodObj->MLCSize << std::endl;\n+    std::cout << \"improve ratio: \" << (double)absMethodObj->oriLCSize / (double)absMethodObj->MLCSize - 1 << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n@@ -187,195 +188,5 @@\n     delete absMethodObj->dataWrite_;\n     delete chunkerObj;\n     delete absMethodObj;\n     return 0;\n-}\n-#include <iostream>\n-#include <string>\n-#include <csignal>\n-#include <sstream>\n-#include <chrono>\n-\n-#include \"../../include/allmethod.h\"\n-\n-using namespace std;\n-\n-void signalHandler(int signum)\n-{\n-    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n-    exit(signum);\n-}\n-\n-int main(int argc, char **argv)\n-{\n-    signal(SIGINT, signalHandler);\n-\n-    uint32_t chunkingType;\n-    uint32_t compressionMethod;\n-    uint32_t backupNum;\n-    double ratio = 8;\n-    string dirName;\n-    string myName = \"MC\";\n-\n-    vector<string> readfileList;\n-\n-    const char optString[] = \"i:m:c:n:r:\";\n-    if (argc != sizeof(optString) && argc != sizeof(optString) - 2)\n-    {\n-        cout << \"argc is \" << argc << endl;\n-        cout << \"Usage: \" << argv[0] << \" -i <input file> -m <chunking method> -c <compression method> -n <process number> -r <Bisearch fault ratio>\" << endl;\n-        return 0;\n-    }\n-\n-    // Grab command-line instructions\n-    int option = 0;\n-    while ((option = getopt(argc, argv, optString)) != -1)\n-    {\n-        switch (option)\n-        {\n-        case 'i':\n-            dirName.assign(optarg);\n-            break;\n-        case 'c':\n-            chunkingType = atoi(optarg);\n-            break;\n-        case 'm':\n-            compressionMethod = atoi(optarg);\n-            break;\n-        case 'n':\n-            backupNum = atoi(optarg);\n-            break;\n-        case 'r':\n-            ratio = atoi(optarg);\n-            break;\n-        default:\n-            break;\n-        }\n-    }\n-\n-    AbsMethod *absMethodObj;\n-    Chunker *chunkerObj = new Chunker(chunkingType);\n-\n-    MessageQueue<Chunk_t> *chunkerMQ = new MessageQueue<Chunk_t>(CHUNK_QUEUE_SIZE);\n-\n-    switch (compressionMethod)\n-    {\n-    case DEDUP:\n-    {\n-        absMethodObj = new Dedup();\n-        break;\n-    }\n-    case NTRANSFORM:\n-    {\n-        absMethodObj = new NTransForm();\n-        break;\n-    }\n-    case FINESSE:\n-    {\n-        absMethodObj = new Finesse();\n-        break;\n-    }\n-    case ODESS:\n-    {\n-        absMethodObj = new Odess();\n-        break;\n-    }\n-    case PALANTIR:\n-    {\n-        absMethodObj = new Palantir();\n-        break;\n-    }\n-    case LOCALITY:\n-    {\n-        absMethodObj = new LocalDedup();\n-        break;\n-    }\n-    default:\n-        break;\n-    }\n-\n-    tool::traverse_dir(dirName, readfileList, nofilter);\n-    sort(readfileList.begin(), readfileList.end(), AbsMethod::compareNat);\n-\n-    boost::thread *thTmp[2] = {nullptr};\n-    boost::thread::attributes attrs;\n-    attrs.set_stack_size(THREAD_STACK_SIZE);\n-    chunkerObj->SetOutputMQ(chunkerMQ);\n-    absMethodObj->SetInputMQ(chunkerMQ);\n-    absMethodObj->dataWrite_ = new dataWrite();\n-\n-    // new design\n-    // if (chunkingType == TAR_MultiHeader)\n-    // {\n-    //     MessageQueue<uint64_t> *MaskMQ = new MessageQueue<uint64_t>(CHUNK_QUEUE_SIZE);\n-    //     chunkerObj->SetOutputMaskMQ(MaskMQ);\n-    //     absMethodObj->SetInputMaskMQ(MaskMQ);\n-    // }\n-    auto startsum = std::chrono::high_resolution_clock::now();\n-    if (chunkingType == MTAR)\n-    {\n-        chunkerObj->MTar(readfileList, backupNum);\n-    }\n-    for (auto i = 0; i < backupNum; i++)\n-    {\n-        auto startTmp = std::chrono::high_resolution_clock::now();\n-        // set backup name\n-        chunkerObj->LoadChunkFile(readfileList[i]);\n-        absMethodObj->SetFilename(readfileList[i]);\n-        absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n-        // thread running\n-        thTmp[0] = new boost::thread(attrs, boost::bind(&Chunker::Chunking, chunkerObj));\n-        thTmp[1] = new boost::thread(attrs, boost::bind(&AbsMethod::ProcessTrace, absMethodObj));\n-        for (auto it : thTmp)\n-        {\n-            it->join();\n-        }\n-        for (auto it : thTmp)\n-        {\n-            delete it;\n-        }\n-        auto endTmp = std::chrono::high_resolution_clock::now();\n-        auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n-    }\n-    absMethodObj->Migratory();\n-    absMethodObj->MLC();\n-    absMethodObj->OriGenerate(readfileList, backupNum);\n-    absMethodObj->OriLC(\"ori\");\n-    // auto endsum = std::chrono::high_resolution_clock::now();\n-    // auto sumTime = (endsum - startsum);\n-    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n-    // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n-    std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n-    std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n-    std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n-    std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n-\n-    // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n-    // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n-    // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n-    // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n-    // if (compressionMethod != 5)\n-    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n-    // else\n-    // absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n-\n-    //  restore backup if you need, but it's not necessary\n-    // if (chunkingType != TAR_MultiHeader)\n-    //     for (auto i = 0; i < backupNum; i++)\n-    //     {\n-    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n-    //         absMethodObj->dataWrite_->restoreFile(readfileList[i]);\n-    //     }\n-    // else\n-    //     for (auto i = 0; i < backupNum; i++)\n-    //     {\n-    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n-    //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n-    //     }\n-\n-    // string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n-    // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n-    delete absMethodObj->dataWrite_;\n-    delete chunkerObj;\n-    delete absMethodObj;\n-    return 0;\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733466391748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,12 +155,12 @@\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n     std::cout << \" -i \" << dirName << \" -c \" << chunkingType << \" -m \" << compressionMethod << \" -n \" << backupNum << endl;\n     std::cout << \"logical size : \" << absMethodObj->logicalchunkSize << std::endl;\n     std::cout << \"Ori lossless compression size : \" << absMethodObj->oriLCSize << std::endl;\n+    std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n     std::cout << \"Ori lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / (double)absMethodObj->oriLCSize << std::endl;\n-    std::cout << \"Migratory lossless compression size : \" << absMethodObj->MLCSize << std::endl;\n     std::cout << \"Migration lossless compression ratio: \" << (double)absMethodObj->logicalchunkSize / (double)absMethodObj->MLCSize << std::endl;\n-    std::cout << \"improve ratio: \" << (double)absMethodObj->oriLCSize / (double)absMethodObj->MLCSize - 1 << std::endl;\n+    std::cout << \"improve ratio: \" << ((double)absMethodObj->oriLCSize / (double)absMethodObj->MLCSize - 1) * 100 << \"%\" << std::endl;\n     // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n     // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n     // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n     // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n"
                }
            ],
            "date": 1733384965800,
            "name": "Commit-0",
            "content": "#include <iostream>\n#include <string>\n#include <csignal>\n#include <sstream>\n#include <chrono>\n\n#include \"../../include/allmethod.h\"\n\nusing namespace std;\n\nvoid signalHandler(int signum)\n{\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n    exit(signum);\n}\n\nint main(int argc, char **argv)\n{\n    signal(SIGINT, signalHandler);\n\n    uint32_t chunkingType;\n    uint32_t compressionMethod;\n    uint32_t backupNum;\n    double ratio = 8;\n    string dirName;\n    string myName = \"MC\";\n\n    vector<string> readfileList;\n\n    const char optString[] = \"i:m:c:n:r:\";\n    if (argc != sizeof(optString) && argc != sizeof(optString) - 2)\n    {\n        cout << \"argc is \" << argc << endl;\n        cout << \"Usage: \" << argv[0] << \" -i <input file> -m <chunking method> -c <compression method> -n <process number> -r <Bisearch fault ratio>\" << endl;\n        return 0;\n    }\n\n    // Grab command-line instructions\n    int option = 0;\n    while ((option = getopt(argc, argv, optString)) != -1)\n    {\n        switch (option)\n        {\n        case 'i':\n            dirName.assign(optarg);\n            break;\n        case 'c':\n            chunkingType = atoi(optarg);\n            break;\n        case 'm':\n            compressionMethod = atoi(optarg);\n            break;\n        case 'n':\n            backupNum = atoi(optarg);\n            break;\n        case 'r':\n            ratio = atoi(optarg);\n            break;\n        default:\n            break;\n        }\n    }\n\n    AbsMethod *absMethodObj;\n    Chunker *chunkerObj = new Chunker(chunkingType);\n\n    MessageQueue<Chunk_t> *chunkerMQ = new MessageQueue<Chunk_t>(CHUNK_QUEUE_SIZE);\n\n    switch (compressionMethod)\n    {\n    case DEDUP:\n    {\n        absMethodObj = new Dedup();\n        break;\n    }\n    case NTRANSFORM:\n    {\n        absMethodObj = new NTransForm();\n        break;\n    }\n    case FINESSE:\n    {\n        absMethodObj = new Finesse();\n        break;\n    }\n    case ODESS:\n    {\n        absMethodObj = new Odess();\n        break;\n    }\n    case PALANTIR:\n    {\n        absMethodObj = new Palantir();\n        break;\n    }\n    case LOCALITY:\n    {\n        absMethodObj = new LocalDedup();\n        break;\n    }\n    default:\n        break;\n    }\n\n    tool::traverse_dir(dirName, readfileList, nofilter);\n    sort(readfileList.begin(), readfileList.end(), AbsMethod::compareNat);\n\n    boost::thread *thTmp[2] = {nullptr};\n    boost::thread::attributes attrs;\n    attrs.set_stack_size(THREAD_STACK_SIZE);\n    chunkerObj->SetOutputMQ(chunkerMQ);\n    absMethodObj->SetInputMQ(chunkerMQ);\n    absMethodObj->dataWrite_ = new dataWrite();\n\n    // new design\n    // if (chunkingType == TAR_MultiHeader)\n    // {\n    //     MessageQueue<uint64_t> *MaskMQ = new MessageQueue<uint64_t>(CHUNK_QUEUE_SIZE);\n    //     chunkerObj->SetOutputMaskMQ(MaskMQ);\n    //     absMethodObj->SetInputMaskMQ(MaskMQ);\n    // }\n    auto startsum = std::chrono::high_resolution_clock::now();\n    if (chunkingType == MTAR)\n    {\n        chunkerObj->MTar(readfileList, backupNum);\n    }\n    for (auto i = 0; i < backupNum; i++)\n    {\n        auto startTmp = std::chrono::high_resolution_clock::now();\n        // set backup name\n        chunkerObj->LoadChunkFile(readfileList[i]);\n        absMethodObj->SetFilename(readfileList[i]);\n        absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n        // thread running\n        thTmp[0] = new boost::thread(attrs, boost::bind(&Chunker::Chunking, chunkerObj));\n        thTmp[1] = new boost::thread(attrs, boost::bind(&AbsMethod::ProcessTrace, absMethodObj));\n        for (auto it : thTmp)\n        {\n            it->join();\n        }\n        for (auto it : thTmp)\n        {\n            delete it;\n        }\n        auto endTmp = std::chrono::high_resolution_clock::now();\n        auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n        if (compressionMethod != 5)\n            absMethodObj->Version_log(TimeTmp);\n        else\n            absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n    }\n\n    auto endsum = std::chrono::high_resolution_clock::now();\n    auto sumTime = (endsum - startsum);\n    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n    std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n    tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n    tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n    tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n    tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n    if (compressionMethod != 5)\n        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n    else\n        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n\n    //  restore backup if you need, but it's not necessary\n    // if (chunkingType != TAR_MultiHeader)\n    //     for (auto i = 0; i < backupNum; i++)\n    //     {\n    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n    //         absMethodObj->dataWrite_->restoreFile(readfileList[i]);\n    //     }\n    // else\n    //     for (auto i = 0; i < backupNum; i++)\n    //     {\n    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n    //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n    //     }\n\n    string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n    // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n    delete absMethodObj->dataWrite_;\n    delete chunkerObj;\n    delete absMethodObj;\n    return 0;\n}"
        }
    ]
}
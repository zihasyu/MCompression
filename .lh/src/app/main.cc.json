{
    "sourceFile": "src/app/main.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1733384965800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733385501645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,21 +149,21 @@\n         else\n             absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n     }\n \n-    auto endsum = std::chrono::high_resolution_clock::now();\n-    auto sumTime = (endsum - startsum);\n-    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n-    std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n-    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n-    tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n-    tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n-    tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n-    tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n-    if (compressionMethod != 5)\n-        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n-    else\n-        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n+    // auto endsum = std::chrono::high_resolution_clock::now();\n+    // auto sumTime = (endsum - startsum);\n+    // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n+    // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n+    // tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n+    // tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n+    // tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n+    // tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n+    // tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n+    // if (compressionMethod != 5)\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n+    // else\n+    //     absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n \n     //  restore backup if you need, but it's not necessary\n     // if (chunkingType != TAR_MultiHeader)\n     //     for (auto i = 0; i < backupNum; i++)\n@@ -177,9 +177,9 @@\n     //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n     //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n     //     }\n \n-    string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n+    // string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n     // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n     delete absMethodObj->dataWrite_;\n     delete chunkerObj;\n     delete absMethodObj;\n"
                },
                {
                    "date": 1733386974371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,14 +143,11 @@\n             delete it;\n         }\n         auto endTmp = std::chrono::high_resolution_clock::now();\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n-        if (compressionMethod != 5)\n-            absMethodObj->Version_log(TimeTmp);\n-        else\n-            absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n     }\n-\n+    absMethodObj->Migratory();\n+    absMethodObj->MLC();\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733388154034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,8 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n+    absMethodObj->OriLC(dirName);\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                },
                {
                    "date": 1733388283114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n         auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n     }\n     absMethodObj->Migratory();\n     absMethodObj->MLC();\n-    absMethodObj->OriLC(dirName);\n+    absMethodObj->OriLC(readfileList[0]);\n     // auto endsum = std::chrono::high_resolution_clock::now();\n     // auto sumTime = (endsum - startsum);\n     // auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n     // std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n"
                }
            ],
            "date": 1733384965800,
            "name": "Commit-0",
            "content": "#include <iostream>\n#include <string>\n#include <csignal>\n#include <sstream>\n#include <chrono>\n\n#include \"../../include/allmethod.h\"\n\nusing namespace std;\n\nvoid signalHandler(int signum)\n{\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n    exit(signum);\n}\n\nint main(int argc, char **argv)\n{\n    signal(SIGINT, signalHandler);\n\n    uint32_t chunkingType;\n    uint32_t compressionMethod;\n    uint32_t backupNum;\n    double ratio = 8;\n    string dirName;\n    string myName = \"MC\";\n\n    vector<string> readfileList;\n\n    const char optString[] = \"i:m:c:n:r:\";\n    if (argc != sizeof(optString) && argc != sizeof(optString) - 2)\n    {\n        cout << \"argc is \" << argc << endl;\n        cout << \"Usage: \" << argv[0] << \" -i <input file> -m <chunking method> -c <compression method> -n <process number> -r <Bisearch fault ratio>\" << endl;\n        return 0;\n    }\n\n    // Grab command-line instructions\n    int option = 0;\n    while ((option = getopt(argc, argv, optString)) != -1)\n    {\n        switch (option)\n        {\n        case 'i':\n            dirName.assign(optarg);\n            break;\n        case 'c':\n            chunkingType = atoi(optarg);\n            break;\n        case 'm':\n            compressionMethod = atoi(optarg);\n            break;\n        case 'n':\n            backupNum = atoi(optarg);\n            break;\n        case 'r':\n            ratio = atoi(optarg);\n            break;\n        default:\n            break;\n        }\n    }\n\n    AbsMethod *absMethodObj;\n    Chunker *chunkerObj = new Chunker(chunkingType);\n\n    MessageQueue<Chunk_t> *chunkerMQ = new MessageQueue<Chunk_t>(CHUNK_QUEUE_SIZE);\n\n    switch (compressionMethod)\n    {\n    case DEDUP:\n    {\n        absMethodObj = new Dedup();\n        break;\n    }\n    case NTRANSFORM:\n    {\n        absMethodObj = new NTransForm();\n        break;\n    }\n    case FINESSE:\n    {\n        absMethodObj = new Finesse();\n        break;\n    }\n    case ODESS:\n    {\n        absMethodObj = new Odess();\n        break;\n    }\n    case PALANTIR:\n    {\n        absMethodObj = new Palantir();\n        break;\n    }\n    case LOCALITY:\n    {\n        absMethodObj = new LocalDedup();\n        break;\n    }\n    default:\n        break;\n    }\n\n    tool::traverse_dir(dirName, readfileList, nofilter);\n    sort(readfileList.begin(), readfileList.end(), AbsMethod::compareNat);\n\n    boost::thread *thTmp[2] = {nullptr};\n    boost::thread::attributes attrs;\n    attrs.set_stack_size(THREAD_STACK_SIZE);\n    chunkerObj->SetOutputMQ(chunkerMQ);\n    absMethodObj->SetInputMQ(chunkerMQ);\n    absMethodObj->dataWrite_ = new dataWrite();\n\n    // new design\n    // if (chunkingType == TAR_MultiHeader)\n    // {\n    //     MessageQueue<uint64_t> *MaskMQ = new MessageQueue<uint64_t>(CHUNK_QUEUE_SIZE);\n    //     chunkerObj->SetOutputMaskMQ(MaskMQ);\n    //     absMethodObj->SetInputMaskMQ(MaskMQ);\n    // }\n    auto startsum = std::chrono::high_resolution_clock::now();\n    if (chunkingType == MTAR)\n    {\n        chunkerObj->MTar(readfileList, backupNum);\n    }\n    for (auto i = 0; i < backupNum; i++)\n    {\n        auto startTmp = std::chrono::high_resolution_clock::now();\n        // set backup name\n        chunkerObj->LoadChunkFile(readfileList[i]);\n        absMethodObj->SetFilename(readfileList[i]);\n        absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n        // thread running\n        thTmp[0] = new boost::thread(attrs, boost::bind(&Chunker::Chunking, chunkerObj));\n        thTmp[1] = new boost::thread(attrs, boost::bind(&AbsMethod::ProcessTrace, absMethodObj));\n        for (auto it : thTmp)\n        {\n            it->join();\n        }\n        for (auto it : thTmp)\n        {\n            delete it;\n        }\n        auto endTmp = std::chrono::high_resolution_clock::now();\n        auto TimeTmp = std::chrono::duration_cast<std::chrono::duration<double>>(endTmp - startTmp).count();\n        if (compressionMethod != 5)\n            absMethodObj->Version_log(TimeTmp);\n        else\n            absMethodObj->Version_log(TimeTmp, chunkerObj->ChunkTime.count());\n    }\n\n    auto endsum = std::chrono::high_resolution_clock::now();\n    auto sumTime = (endsum - startsum);\n    auto sumTimeInSeconds = std::chrono::duration_cast<std::chrono::seconds>(endsum - startsum).count();\n    std::cout << \"Time taken by for loop: \" << sumTimeInSeconds << \" s \" << std::endl;\n    tool::Logging(myName.c_str(), \"logical Chunk Num is %d\\n\", absMethodObj->logicalchunkNum);\n    tool::Logging(myName.c_str(), \"unique Chunk Num is %d\\n\", absMethodObj->uniquechunkNum);\n    tool::Logging(myName.c_str(), \"Total logical size is %lu\\n\", absMethodObj->logicalchunkSize);\n    tool::Logging(myName.c_str(), \"Total compressed size is %lu\\n\", absMethodObj->uniquechunkSize);\n    tool::Logging(myName.c_str(), \"Compression ratio is %.4f\\n\", (double)absMethodObj->logicalchunkSize / (double)absMethodObj->uniquechunkSize);\n    if (compressionMethod != 5)\n        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio);\n    else\n        absMethodObj->PrintChunkInfo(dirName, chunkingType, compressionMethod, backupNum, sumTimeInSeconds, ratio, chunkerObj->ChunkTime.count());\n\n    //  restore backup if you need, but it's not necessary\n    // if (chunkingType != TAR_MultiHeader)\n    //     for (auto i = 0; i < backupNum; i++)\n    //     {\n    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n    //         absMethodObj->dataWrite_->restoreFile(readfileList[i]);\n    //     }\n    // else\n    //     for (auto i = 0; i < backupNum; i++)\n    //     {\n    //         absMethodObj->dataWrite_->SetFilename(readfileList[i]);\n    //         absMethodObj->dataWrite_->restoreHeaderFile(readfileList[i]);\n    //     }\n\n    string fileName = \"C\" + to_string(chunkingType) + \"_M\" + to_string(compressionMethod);\n    // absMethodObj->dataWrite_->Save_to_File_unique(fileName);\n    delete absMethodObj->dataWrite_;\n    delete chunkerObj;\n    delete absMethodObj;\n    return 0;\n}"
        }
    ]
}